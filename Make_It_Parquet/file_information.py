#! /usr/bin/env python3

from pathlib import Path
import os
import stat
import re
from typing import NamedTuple


class FileInfo(NamedTuple):
    path: Path
    stat_obj: os.stat_result
    file_name: str
    file_size: int
    file_extension: str
    file_or_directory: str


def resolve_path(input: Path | os.DirEntry[str]) -> Path:
    """Resolves input path."""
    if isinstance(input, Path):
        return input.resolve()
    else:
        return Path(input.path).resolve()


def get_file_stat(
    input: Path | os.DirEntry[str], resolved_path: Path
) -> os.stat_result:
    """Creates a file stat of the target file, which can be submitted as a path or an os.DirEntry object.

    Args:
        input: The target file in the form of a Path or os.DirEntry.
        resolved_path: Resolved path to be used instead of user entered path if object passed is a path.

    Returns:
        os.stat_result
    """
    if isinstance(input, Path):
        return resolved_path.stat()
    else:
        return input.stat()


def file_or_dir_from_stat(stat_obj: os.stat_result) -> str:
    """Determines if an os.stat_result object represents a file or directory."""
    return "file" if stat.S_ISREG(stat_obj.st_mode) else "directory"


def create_file_info(input: Path | os.DirEntry[str]) -> FileInfo:
    """Creates an info dataclass for the given input path."""
    path = resolve_path(input)
    stat_obj = get_file_stat(input, path)
    file_name = path.name
    file_size = stat_obj.st_size
    file_extension = path.suffix
    file_or_directory = file_or_dir_from_stat(stat_obj)
    file_info = FileInfo(
        path, stat_obj, file_name, file_size, file_extension, file_or_directory
    )
    return file_info


def replace_alias_in_string(input_ext: str) -> str:
    """
    Replace the matched string in the input extension with the correct case.

    This method takes in the input extension and returns the same extension
    with the correct case. If the extension is not found in the string, the
    original string is returned.

    Args:
        self (str): The input extension.

    Returns:
        str: The matched string with the correct case.
    """
    pattern = re.compile(re.escape(input_ext), re.IGNORECASE)
    result, count = pattern.subn(replacer, input_ext)
    if count == 0:
        result = f"{input_ext}"
    return result


def replacer(input_ext: str, match: re.Match[str]) -> str:
    """
    Replace the matched string in the input extension with the correct case.

    Args:
    match: re.Match
        The matched string.

    Returns:
    str:
        The matched string with the correct case.
    """
    orig: str = match.group()
    if orig.isupper():
        return input_ext.upper()
    elif orig.islower():
        return input_ext.lower()
    elif orig[0].isupper() and orig[1:].islower():
        return input_ext.capitalize()
    else:
        return input_ext


def generate_output_name(input_ext: str, output_ext: str, input_path: Path) -> str:
    """
    Generate a name for the output file.

    If the input extension is present in the input file name (case-insensitive),
    the output name is generated by replacing the input extension with the
    correct case. Otherwise, the output name is generated by appending the
    output extension to the input file name.

    Returns:
        str: The generated output name.
    """
    if input_ext and input_ext.lower() in input_path.name.lower():
        return replace_alias_in_string(input_ext)
    else:
        return f"{input_path.name}_{output_ext}"


def generate_output_path(input_path: Path, output_ext: str) -> Path:
    """
    Generate a path for the output file.

    Args:
        input_path (Path): The path to the input file.
        output_ext (str): The output file extension.

    Returns:
        Path: The path to the output file.
    """
    return input_path.with_suffix(f".{output_ext}")
