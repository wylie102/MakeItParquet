#! /usr/bin/env python3

import argparse
import logging
from dataclasses import dataclass
from pathlib import Path

from ..extension_mapping import ALIAS_TO_EXTENSION_MAP


@dataclass
class CLIArgs:
    """A dataclass to ensure correct typing of command line arguments"""

    input_path: Path | None
    output_path: Path | None
    input_format: str | None
    output_format: str | None
    excel_sheet: str | None
    excel_range: str | None
    log_level: str | None


def parse_cli_arguments() -> CLIArgs:
    """
    Parse command line arguments.

    Returns:
        argparse.Namespace: Parsed CLI arguments
    """
    parser = argparse.ArgumentParser(
        description="Make-it-Parquet!: Conversion of data files powered by DuckDB"
    )
    # Input path.
    _ = parser.add_argument(
        "input_path", help="Path to the input file or directory", type=Path
    )
    # Output path.
    _ = parser.add_argument(
        "-op", "--output_path", help="Specify output file path", type=Path
    )
    # Input format.
    _ = parser.add_argument(
        "-i", "--input_format", help="Specify input file format", type=str
    )
    # Output format.
    _ = parser.add_argument(
        "-o", "--output_format", help="Specify output file format", type=str
    )
    # Excel sheet.
    _ = parser.add_argument(
        "-es", "--excel_sheet", help="Excel sheet (name or number)", type=str
    )
    # Excel range.
    _ = parser.add_argument(
        "-er", "--excel_range", help="Excel range (e.g., A2:E7)", type=str
    )
    # Log level.
    _ = parser.add_argument(
        "--log-level",
        help="Set the logging level (e.g., DEBUG, INFO, WARNING)",
        default="INFO",
    )
    args = CLIArgs(None, None, None, None, None, None, None)
    # Parse arguments and create argparse.Namespace object (args).
    return parser.parse_args(namespace=args)


def _check_format_supported(format: str) -> bool:
    """
    Check if a format is supported.
    """
    if format in ALIAS_TO_EXTENSION_MAP:
        return True
    else:
        logging.warning(f"Received invalid forma: {format}")
        return False


def _map_format_to_extension(format: str) -> str:
    """
    Map a format to an extension.
    """
    return ALIAS_TO_EXTENSION_MAP[format]


def _validate_format(format: str | None) -> str | None:
    """
    Validate a format string by checking its existence, support, and then mapping it to an extension.
    """
    # Check if format is provided.
    if not format:
        return None

    # Check if supported
    if not _check_format_supported(format):
        return None

    # Map format to extension
    return _map_format_to_extension(format)


def _input_output_extensions_same(
    input_ext: str | None, output_ext: str | None
) -> bool:
    """
    Check if input and output extensions are the same.
    """
    # Raise error if input and output formats are the same.
    if input_ext and output_ext:
        if input_ext == output_ext:
            # log warning
            logging.warning(
                "Input and output extensions cannot be the same. Input extension will be automatically detected, please specify output extension."
            )
            return True
        else:
            return False
    else:
        return False


def get_input_output_extensions(
    input_format: str | None, output_format: str | None
) -> tuple[str | None, str | None]:
    """
    Validate input and output format arguments that were passed in directly from the command line.
    Does not interact with arguments generated by prompts.
    If no (valid) arguments are provided input_ext and output_ext will be None.

    Returns:
        Tuple[Optional[str], Optional[str]]: Validated input and output extensions
    """
    input_ext = _validate_format(input_format)
    output_ext = _validate_format(output_format)
    # If supplied extensions are the same, set them to None.
    # Input will now be detected automatically.
    # Output will be supplied via user prompt as part of the main program.
    if _input_output_extensions_same(input_ext, output_ext):
        input_ext = None
        output_ext = None
    # Return input and output extensions.
    return input_ext, output_ext
